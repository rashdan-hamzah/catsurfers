<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dragon Dash</title>
  <style>
    body {
      background: #cce6ff;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      font-family: 'Segoe UI', Arial, sans-serif;
    }
    canvas {
      background: #e0f7fa;
      margin-top: 30px;
      box-shadow: 0 4px 24px #0002;
      border-radius: 18px;
      display: block;
    }
    #score {
      font-size: 1.5em;
      margin-top: 20px;
      color: #006064;
      font-weight: bold;
      text-shadow: 1px 1px 2px #fff8;
    }
    #restart {
      margin-top: 10px;
      padding: 10px 24px;
      font-size: 1em;
      border-radius: 8px;
      border: none;
      background: #80deea;
      color: #006064;
      cursor: pointer;
      box-shadow: 0 2px 8px #0001;
      display: none;
    }
    #restart:active {
      background: #4dd0e1;
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <canvas id="game" width="400" height="600"></canvas>
  <button id="restart">Restart</button>
  <script>
    // Game constants
    const TILE_SIZE = 40;
    const LANE_HEIGHT = 60;
    const COLS = 10;
    const ROWS = 15;
    const CANVAS_WIDTH = TILE_SIZE * COLS;
    const CANVAS_HEIGHT = LANE_HEIGHT * ROWS;

    // Dragon character
    const dragon = {
      x: Math.floor(COLS / 2),
      y: ROWS - 2,
      color: "#67e8f9",
      size: TILE_SIZE * 0.9,
      alive: true,
      cuteFace: true
    };

    // Obstacles and lanes
    const lanes = [];
    const obstaclesPerLane = 3;
    const laneSpeeds = [0, 1, -1, 1.5, -1.5, 2, -2, 2.5, -2.5, 1, -1, 1.2, -1.2, 1.3, -1.3];

    // Score
    let score = 0, maxScore = 0;
    let gameOver = false;

    // Canvas setup
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    canvas.width = CANVAS_WIDTH; canvas.height = CANVAS_HEIGHT;

    // Score display
    const scoreDiv = document.getElementById("score");
    const restartBtn = document.getElementById("restart");

    // Initialize lanes and obstacles
    function resetLanes() {
      lanes.length = 0;
      for (let i = 0; i < ROWS; i++) {
        if (i < 2) {
          lanes.push({ obstacles: [], speed: 0 }); // Safe zone at start
          continue;
        }
        let speed = laneSpeeds[i % laneSpeeds.length];
        let obstacles = [];
        for (let j = 0; j < obstaclesPerLane; j++) {
          let obsX = Math.random() * CANVAS_WIDTH;
          obstacles.push({ x: obsX, width: TILE_SIZE * (1.2 + Math.random()), color: "#ffab91" });
        }
        lanes.push({ obstacles, speed });
      }
    }

    // Draw dragon
    function drawDragon() {
      let px = dragon.x * TILE_SIZE + TILE_SIZE/2;
      let py = dragon.y * LANE_HEIGHT + LANE_HEIGHT/2;
      ctx.save();
      ctx.translate(px, py);
      // Body
      ctx.beginPath();
      ctx.arc(0, 0, dragon.size/2, 0, Math.PI * 2);
      ctx.fillStyle = dragon.color;
      ctx.shadowColor = "#22d3ee";
      ctx.shadowBlur = 8;
      ctx.fill();
      ctx.shadowBlur = 0;
      // Eyes
      ctx.fillStyle = "#fff";
      ctx.beginPath(); ctx.arc(-8, -4, 6, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(8, -4, 6, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = "#222";
      ctx.beginPath(); ctx.arc(-8, -3, 3, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(8, -3, 3, 0, Math.PI*2); ctx.fill();
      // Blush
      ctx.fillStyle = "#fbbf24";
      ctx.beginPath(); ctx.arc(-14, 6, 2.5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(14, 6, 2.5, 0, Math.PI*2); ctx.fill();
      // Smile
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 6, 8, Math.PI*0.1, Math.PI*0.9);
      ctx.stroke();
      // Wings
      ctx.strokeStyle = "#60a5fa";
      ctx.lineWidth = 4;
      ctx.beginPath(); ctx.moveTo(-16,0); ctx.lineTo(-30,-12); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(16,0); ctx.lineTo(30,-12); ctx.stroke();
      ctx.restore();
    }

    // Draw obstacles
    function drawObstacles() {
      for (let row = 2; row < ROWS; row++) {
        let lane = lanes[row];
        for (let obs of lane.obstacles) {
          ctx.fillStyle = obs.color;
          ctx.fillRect(obs.x, row * LANE_HEIGHT + 10, obs.width, LANE_HEIGHT - 20);
          ctx.strokeStyle = "#d84315";
          ctx.strokeRect(obs.x, row * LANE_HEIGHT + 10, obs.width, LANE_HEIGHT - 20);
        }
      }
    }

    // Draw ground and lanes
    function drawBackground() {
      for (let row = 0; row < ROWS; row++) {
        ctx.fillStyle = (row === 0 || row === 1) ? "#a7f3d0" : (row % 2 ? "#fcd34d" : "#fbbf24");
        ctx.fillRect(0, row * LANE_HEIGHT, CANVAS_WIDTH, LANE_HEIGHT);
      }
    }

    // Draw everything
    function draw() {
      ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      drawBackground();
      drawObstacles();
      drawDragon();
    }

    // Move obstacles
    function moveObstacles() {
      for (let row = 2; row < ROWS; row++) {
        let lane = lanes[row];
        for (let obs of lane.obstacles) {
          obs.x += lane.speed;
          if (lane.speed > 0 && obs.x > CANVAS_WIDTH) obs.x = -obs.width;
          if (lane.speed < 0 && obs.x + obs.width < 0) obs.x = CANVAS_WIDTH;
        }
      }
    }

    // Collision detection
    function checkCollision() {
      if (dragon.y < 2) return false; // Safe zone
      let lane = lanes[dragon.y];
      let px = dragon.x * TILE_SIZE;
      for (let obs of lane.obstacles) {
        if (px + TILE_SIZE*0.1 < obs.x + obs.width &&
            px + TILE_SIZE*0.9 > obs.x) {
          // Collision!
          return true;
        }
      }
      return false;
    }

    // Move dragon
    function moveDragon(dx, dy) {
      if (!dragon.alive) return;
      let nx = dragon.x + dx;
      let ny = dragon.y + dy;
      if (nx < 0 || nx >= COLS) return;
      if (ny < 0 || ny >= ROWS) return;
      dragon.x = nx; dragon.y = ny;
      if (dragon.y < ROWS - 2 && dragon.y > score) {
        score = dragon.y;
        updateScore();
      }
      if (checkCollision()) {
        dragon.alive = false;
        gameOver = true;
        showGameOver();
      }
    }

    // Handle input
    document.addEventListener("keydown", (e) => {
      if (!dragon.alive) return;
      if (e.key === "ArrowUp" || e.key === "w") moveDragon(0,-1);
      if (e.key === "ArrowDown" || e.key === "s") moveDragon(0,1);
      if (e.key === "ArrowLeft" || e.key === "a") moveDragon(-1,0);
      if (e.key === "ArrowRight" || e.key === "d") moveDragon(1,0);
    });

    // Update score display
    function updateScore() {
      scoreDiv.textContent = `Score: ${score}`;
    }

    // Show game over
    function showGameOver() {
      scoreDiv.textContent = `Game Over! Score: ${score}`;
      restartBtn.style.display = "inline-block";
    }

    // Restart game
    function restartGame() {
      dragon.x = Math.floor(COLS / 2);
      dragon.y = ROWS - 2;
      dragon.alive = true;
      score = 0;
      gameOver = false;
      updateScore();
      restartBtn.style.display = "none";
      resetLanes();
      draw();
    }
    restartBtn.addEventListener("click", restartGame);

    // Game loop
    function gameLoop() {
      if (!gameOver) {
        moveObstacles();
        if (checkCollision()) {
          dragon.alive = false;
          gameOver = true;
          showGameOver();
        }
        draw();
      }
      requestAnimationFrame(gameLoop);
    }

    // Initialize game
    function start() {
      resetLanes();
      updateScore();
      draw();
      requestAnimationFrame(gameLoop);
    }
    start();
  </script>
</body>
</html>
